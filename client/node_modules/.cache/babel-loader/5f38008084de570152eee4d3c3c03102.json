{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar BN = require('web3').utils.toBN;\n\nvar abi = require('web3-eth-abi'); //relays are \"down-scored\" in case they timed out a request.\n// they are \"forgiven\" after this timeout.\n\n\nvar DEFAULT_RELAY_TIMEOUT_GRACE_SEC = 60 * 30;\n\nvar ActiveRelayPinger =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  // TODO: 'httpSend' should be on a network layer\n  function ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n    _classCallCheck(this, ActiveRelayPinger);\n\n    this.remainingRelays = filteredRelays.slice();\n    this.httpSend = httpSend;\n    this.pingedRelays = 0;\n    this.relaysCount = filteredRelays.length;\n    this.gasPrice = gasPrice;\n    this.verbose = verbose;\n    this.errors = [];\n  }\n  /**\n   * Ping those relays that were not returned yet. Remove the returned relay (first to respond) from {@link remainingRelays}\n   * @returns the first relay to respond to a ping message. Note: will never return the same relay twice.\n   */\n\n\n  _createClass(ActiveRelayPinger, [{\n    key: \"nextRelay\",\n    value: function () {\n      var _nextRelay = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this = this;\n\n        var firstRelayToRespond, bulkSize, slice;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.remainingRelays.length === 0)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", null);\n\n              case 2:\n                if (!(!firstRelayToRespond && this.remainingRelays.length)) {\n                  _context.next = 19;\n                  break;\n                }\n\n                bulkSize = Math.min(3, this.remainingRelays.length);\n                _context.prev = 4;\n                slice = this.remainingRelays.slice(0, bulkSize);\n\n                if (this.verbose) {\n                  console.log(\"nextRelay: find fastest relay from: \" + JSON.stringify(slice));\n                }\n\n                _context.next = 9;\n                return this.raceToSuccess(slice.map(function (relay) {\n                  return _this.getRelayAddressPing(relay.relayUrl, relay.transactionFee, _this.gasPrice);\n                }));\n\n              case 9:\n                firstRelayToRespond = _context.sent;\n\n                if (this.verbose) {\n                  console.log(\"race finished with a champion: \" + firstRelayToRespond.relayUrl);\n                }\n\n                _context.next = 17;\n                break;\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](4);\n\n                if (this.verbose) {\n                  console.log(\"One batch of relays failed, last error: \", _context.t0);\n                } //none of the first `bulkSize` items matched. remove them, to continue with the next bulk.\n\n\n                this.remainingRelays = this.remainingRelays.slice(bulkSize);\n\n              case 17:\n                _context.next = 2;\n                break;\n\n              case 19:\n                this.remainingRelays = this.remainingRelays.filter(function (a) {\n                  return a.relayUrl !== firstRelayToRespond.relayUrl;\n                });\n                this.pingedRelays++;\n                return _context.abrupt(\"return\", firstRelayToRespond);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 13]]);\n      }));\n\n      function nextRelay() {\n        return _nextRelay.apply(this, arguments);\n      }\n\n      return nextRelay;\n    }()\n    /**\n     * @returns JSON response from the relay server, but adds the requested URL to it:\n     * { relayUrl: url,\n     *   transactionFee: fee,\n     *   RelayServerAddress: address,\n     *   Ready: bool,   //should ignore relays with \"false\"\n     *   MinGasPrice:   //minimum gas requirement by this relay.\n     * }\n     */\n\n  }, {\n    key: \"getRelayAddressPing\",\n    value: function () {\n      var _getRelayAddressPing = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(relayUrl, transactionFee, gasPrice) {\n        var self;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                self = this;\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var callback = function callback(error, body) {\n                    if (error) {\n                      reject(\"Error querying relayer \".concat(relayUrl, \": \").concat(error.message || error.error || error.toString()));\n                      return;\n                    }\n\n                    if (!body) {\n                      reject(\"Empty response from relayer \".concat(relayUrl));\n                      return;\n                    }\n\n                    if (!body.Ready) {\n                      reject(\"Relayer \".concat(relayUrl, \" is not ready\"));\n                      return;\n                    }\n\n                    if (body.MinGasPrice > gasPrice) {\n                      reject(\"Relayer \".concat(relayUrl, \" requires a minimum gas price of \").concat(body.MinGasPrice, \" which is over this transaction gas price (\").concat(gasPrice, \")\"));\n                      return;\n                    }\n\n                    try {\n                      //add extra attributes (relayUrl, transactionFee)\n                      Object.assign(body, {\n                        relayUrl: relayUrl,\n                        transactionFee: transactionFee\n                      });\n                      resolve(body);\n                    } catch (err) {\n                      reject(err);\n                    }\n                  };\n\n                  if (self.verbose) {\n                    console.log(\"getRelayAddressPing URL: \" + relayUrl);\n                  }\n\n                  self.httpSend.send(relayUrl + \"/getaddr\", {}, callback);\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getRelayAddressPing(_x, _x2, _x3) {\n        return _getRelayAddressPing.apply(this, arguments);\n      }\n\n      return getRelayAddressPing;\n    }()\n    /**\n     * From https://stackoverflow.com/a/37235207 (modified to catch exceptions)\n     * Resolves once any promise resolves, ignores the rest, ignores rejections\n     */\n\n  }, {\n    key: \"raceToSuccess\",\n    value: function () {\n      var _raceToSuccess = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(promises) {\n        var _this2 = this;\n\n        var numRejected;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                numRejected = 0;\n                return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  return promises.forEach(function (promise) {\n                    return promise.then(function (res) {\n                      resolve(res);\n                    }).catch(function (err) {\n                      _this2.errors.push(err);\n\n                      if (++numRejected === promises.length) {\n                        reject(\"No response matched filter from any server: \" + err);\n                      }\n                    });\n                  });\n                }));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function raceToSuccess(_x4) {\n        return _raceToSuccess.apply(this, arguments);\n      }\n\n      return raceToSuccess;\n    }()\n  }]);\n\n  return ActiveRelayPinger;\n}();\n\nvar ServerHelper =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function ServerHelper(httpSend, failedRelays, _ref) {\n    var verbose = _ref.verbose,\n        minStake = _ref.minStake,\n        minDelay = _ref.minDelay,\n        relayTimeoutGrace = _ref.relayTimeoutGrace,\n        calculateRelayScore = _ref.calculateRelayScore,\n        relayFilter = _ref.relayFilter,\n        addScoreRandomness = _ref.addScoreRandomness;\n\n    _classCallCheck(this, ServerHelper);\n\n    this.httpSend = httpSend;\n    this.verbose = verbose;\n    this.failedRelays = failedRelays;\n    this.relayTimeoutGrace = relayTimeoutGrace || DEFAULT_RELAY_TIMEOUT_GRACE_SEC;\n    this.addScoreRandomness = addScoreRandomness || Math.random;\n    this.calculateRelayScore = calculateRelayScore || this.defaultCalculateRelayScore.bind(this); //default filter: either calculateRelayScore didn't set \"score\" field,\n    // or if unstakeDelay is below min, or if stake is below min.\n\n    this.relayFilter = relayFilter || function (relay) {\n      return relay.score != null && (!minDelay || BN(relay.unstakeDelay).gte(BN(minDelay))) && (!minStake || BN(relay.stake).gte(BN(minStake)));\n    };\n\n    this.filteredRelays = [];\n    this.isInitialized = false;\n    this.ActiveRelayPinger = ActiveRelayPinger;\n  }\n\n  _createClass(ServerHelper, [{\n    key: \"defaultCalculateRelayScore\",\n    value: function defaultCalculateRelayScore(relay) {\n      //basic score is trasnaction fee (which is %)\n      //higher the better.\n      var score = 1000 - relay.transactionFee;\n      var failedRelay = this.failedRelays[relay.relayUrl];\n\n      if (failedRelay) {\n        var elapsed = (new Date().getTime() - failedRelay.lastError) / 1000;\n        if (elapsed < this.relayTimeoutGrace) score -= 10; //relay failed to answer lately. demote.\n        else delete this.failedRelays[relay.relayUrl];\n      }\n\n      return score;\n    } //compare relay scores.\n    // if they are the same, use addScoreRandomness to shuffle them..\n\n  }, {\n    key: \"compareRelayScores\",\n    value: function compareRelayScores(r1, r2) {\n      var diff = r2.score - r1.score;\n      if (diff) return diff;\n      return this.addScoreRandomness() - 0.5;\n    }\n    /**\n     *\n     * @param {*} relayHubInstance\n     */\n\n  }, {\n    key: \"setHub\",\n    value: function setHub(relayHubInstance) {\n      if (this.relayHubInstance !== relayHubInstance) {\n        this.filteredRelays = [];\n      }\n\n      this.relayHubInstance = relayHubInstance;\n      this.addedAndRemovedSignatures = this.relayHubInstance.options.jsonInterface.filter(function (e) {\n        return e.name === 'RelayAdded' || e.name === 'RelayRemoved';\n      }).map(abi.encodeEventSignature);\n    }\n  }, {\n    key: \"newActiveRelayPinger\",\n    value: function () {\n      var _newActiveRelayPinger = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(fromBlock, gasPrice) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(typeof this.relayHubInstance === 'undefined')) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Must call to setHub first!\");\n\n              case 2:\n                if (!(this.filteredRelays.length == 0 || this.fromBlock !== fromBlock)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                this.fromBlock = fromBlock;\n                _context4.next = 6;\n                return this.fetchRelaysAdded();\n\n              case 6:\n                return _context4.abrupt(\"return\", this.createActiveRelayPinger(this.filteredRelays, this.httpSend, gasPrice, this.verbose));\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function newActiveRelayPinger(_x5, _x6) {\n        return _newActiveRelayPinger.apply(this, arguments);\n      }\n\n      return newActiveRelayPinger;\n    }()\n  }, {\n    key: \"createActiveRelayPinger\",\n    value: function createActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose) {\n      return new ActiveRelayPinger(filteredRelays, httpSend, gasPrice, verbose);\n    }\n    /**\n     * Iterates through all RelayAdded and RelayRemoved logs emitted by given hub\n     * initializes an array {@link filteredRelays} of relays curently registered on given RelayHub contract\n     */\n\n  }, {\n    key: \"fetchRelaysAdded\",\n    value: function () {\n      var _fetchRelaysAdded = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5() {\n        var activeRelays, fromBlock, addedAndRemovedEvents, index, event, args, relay, origRelays, filteredRelays;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                activeRelays = {};\n                fromBlock = this.fromBlock || 2;\n                _context5.next = 4;\n                return this.relayHubInstance.getPastEvents(\"allEvents\", {\n                  fromBlock: fromBlock,\n                  topics: [this.addedAndRemovedSignatures]\n                });\n\n              case 4:\n                addedAndRemovedEvents = _context5.sent;\n\n                if (this.verbose) {\n                  console.log(\"fetchRelaysAdded: found \" + addedAndRemovedEvents.length + \" events\");\n                } //TODO: better filter RelayAdded, RelayRemoved events: otherwise, we'll be scanning all TransactionRelayed too...\n                //since RelayAdded can't be called after RelayRemoved, its OK to scan first for add, and the remove all removed relays.\n\n\n                for (index in addedAndRemovedEvents) {\n                  event = addedAndRemovedEvents[index];\n\n                  if (event.event === \"RelayAdded\") {\n                    args = event.returnValues;\n                    relay = {\n                      address: args.relay,\n                      relayUrl: args.url,\n                      transactionFee: args.transactionFee,\n                      stake: args.stake,\n                      unstakeDelay: args.unstakeDelay\n                    };\n                    relay.score = this.calculateRelayScore(relay);\n                    activeRelays[args.relay] = relay;\n                  } else if (event.event === \"RelayRemoved\") {\n                    delete activeRelays[event.returnValues.relay];\n                  }\n                }\n\n                origRelays = Object.values(activeRelays);\n\n                if (!(origRelays.length === 0)) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                throw new Error(\"No relayers registered in the requested hub at \".concat(this.relayHubInstance.options.address));\n\n              case 10:\n                filteredRelays = origRelays.filter(this.relayFilter).sort(this.compareRelayScores.bind(this));\n\n                if (!(filteredRelays.length == 0)) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                throw new Error(\"No relayers elligible after filtering. Available relayers:\\n\" + origRelays.map(function (r) {\n                  return \" score=\".concat(r.score, \" txFee=\").concat(r.transactionFee, \" stake=\").concat(r.stake, \" unstakeDelay=\").concat(r.unstakeDelay, \" address=\").concat(r.address, \" url=\").concat(r.relayUrl);\n                }));\n\n              case 13:\n                if (this.verbose) {\n                  console.log(\"fetchRelaysAdded: after filtering have \" + filteredRelays.length + \" active relays\");\n                }\n\n                this.filteredRelays = filteredRelays;\n                this.isInitialized = true;\n                return _context5.abrupt(\"return\", filteredRelays);\n\n              case 17:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function fetchRelaysAdded() {\n        return _fetchRelaysAdded.apply(this, arguments);\n      }\n\n      return fetchRelaysAdded;\n    }()\n  }]);\n\n  return ServerHelper;\n}();\n\nmodule.exports = ServerHelper;","map":null,"metadata":{},"sourceType":"script"}