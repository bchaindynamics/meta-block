{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _defineProperty = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _toConsumableArray = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar ethUtils = require('ethereumjs-util');\n\nvar BN = require('bignumber.js');\n\nvar _require = require('web3-utils'),\n    toBN = _require.toBN,\n    soliditySha3 = _require.soliditySha3;\n\nvar relayHubAbi = require('./tabookey-gasless/IRelayHub');\n\nvar relayRecipientAbi = require('./tabookey-gasless/IRelayRecipient');\n\nvar abiDecoder = require('abi-decoder');\n\nabiDecoder.addABI(relayHubAbi);\n\nfunction appendAddress(data, address) {\n  return data + ethUtils.setLengthLeft(ethUtils.toBuffer(address), 32).toString('hex');\n}\n\nfunction callAsJsonRpc(fn, args, id, callback) {\n  var mapResponseFn = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function (x) {\n    return {\n      result: x\n    };\n  };\n  var response = {\n    jsonrpc: \"2.0\",\n    id: id\n  };\n\n  try {\n    fn.apply(void 0, _toConsumableArray(args)).then(function (result) {\n      callback(null, _objectSpread({}, response, {}, mapResponseFn(result)));\n    }).catch(function (err) {\n      callback(_objectSpread({}, response, {\n        error: err.toString()\n      }), null);\n    });\n  } catch (err) {\n    callback(_objectSpread({}, response, {\n      error: err.toString()\n    }));\n  }\n}\n\nfunction toInt(value) {\n  return new BN(value).toNumber();\n}\n\nfunction preconditionCodeToDescription(code) {\n  switch (parseInt(code)) {\n    case 1:\n      return \"wrong signature\";\n\n    case 2:\n      return \"wrong nonce\";\n\n    case 3:\n      return \"recipient reverted in acceptRelayedCall\";\n\n    case 4:\n      return \"invalid status code returned by the recipient\";\n\n    default:\n      return \"error \".concat(code);\n  }\n}\n\nfunction fixTransactionReceiptResponse(resp) {\n  var debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!resp || !resp.result || !resp.result.logs) return resp;\n  var logs = abiDecoder.decodeLogs(resp.result.logs);\n  var canRelayFailed = logs.find(function (e) {\n    return e && e.name == 'CanRelayFailed';\n  });\n  var transactionRelayed = logs.find(function (e) {\n    return e && e.name == 'TransactionRelayed';\n  });\n\n  var setErrorStatus = function setErrorStatus(reason) {\n    if (debug) console.log(\"Setting tx receipt status to zero while fetching tx receipt (\".concat(reason, \")\"));\n    resp.result.status = 0;\n  };\n\n  if (canRelayFailed) {\n    setErrorStatus(\"canRelay failed with \".concat(canRelayFailed.find(function (e) {\n      return e.name == \"reason\";\n    }).value));\n  } else if (transactionRelayed) {\n    var status = transactionRelayed.events.find(function (e) {\n      return e.name == \"status\";\n    }).value;\n\n    if (parseInt(status) !== 0) {\n      // 0 signifies success\n      setErrorStatus(\"reverted relayed transaction with status code \".concat(status));\n    }\n  }\n\n  return resp;\n}\n\nfunction getApprovalData(_x, _x2) {\n  return _getApprovalData.apply(this, arguments);\n}\n\nfunction _getApprovalData() {\n  _getApprovalData = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(approveFunction, options) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n\n            if (!(typeof approveFunction === \"function\")) {\n              _context2.next = 7;\n              break;\n            }\n\n            _context2.next = 4;\n            return approveFunction(options);\n\n          case 4:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 7:\n            return _context2.abrupt(\"return\", '0x');\n\n          case 8:\n            _context2.next = 13;\n            break;\n\n          case 10:\n            _context2.prev = 10;\n            _context2.t0 = _context2[\"catch\"](0);\n            throw new Error(\"Error running approveFunction for transaction: \".concat(_context2.t0.message || _context2.t0));\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 10]]);\n  }));\n  return _getApprovalData.apply(this, arguments);\n}\n\nfunction fixSignature(signature) {\n  // in geth its always 27/28, in ganache its 0/1. Change to 27/28 to prevent\n  // signature malleability if version is 0/1\n  // see https://github.com/ethereum/go-ethereum/blob/v1.8.23/internal/ethapi/api.go#L465\n  var v = parseInt(signature.slice(130, 132), 16);\n\n  if (v < 27) {\n    v += 27;\n  }\n\n  var vHex = v.toString(16);\n  return signature.slice(0, 130) + vHex;\n}\n\nfunction makeApproveFunction(signFn, verbose) {\n  return (\n    /*#__PURE__*/\n    function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(data) {\n        var signature;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.t0 = fixSignature;\n                _context.next = 3;\n                return signFn(soliditySha3({\n                  type: 'address',\n                  value: data.relayerAddress\n                }, {\n                  type: 'address',\n                  value: data.from\n                }, {\n                  type: 'bytes',\n                  value: data.encodedFunctionCall\n                }, {\n                  type: 'uint256',\n                  value: toBN(data.txFee)\n                }, {\n                  type: 'uint256',\n                  value: toBN(data.gasPrice)\n                }, {\n                  type: 'uint256',\n                  value: toBN(data.gas)\n                }, {\n                  type: 'uint256',\n                  value: toBN(data.nonce)\n                }, {\n                  type: 'address',\n                  value: data.relayHubAddress\n                }, {\n                  type: 'address',\n                  value: data.to\n                }));\n\n              case 3:\n                _context.t1 = _context.sent;\n                signature = (0, _context.t0)(_context.t1);\n                if (verbose) console.log(\"Signature for GSN transaction is \".concat(signature));\n                return _context.abrupt(\"return\", signature);\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x3) {\n        return _ref.apply(this, arguments);\n      };\n    }()\n  );\n}\n\n;\n\nfunction createRelayHubFromRecipient(_x4, _x5) {\n  return _createRelayHubFromRecipient.apply(this, arguments);\n}\n\nfunction _createRelayHubFromRecipient() {\n  _createRelayHubFromRecipient = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(web3, recipientAddress) {\n    var relayRecipient, relayHubAddress, code, relayHub, hubVersion;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            relayRecipient = createRelayRecipient(web3, recipientAddress);\n            _context3.prev = 1;\n            _context3.next = 4;\n            return relayRecipient.methods.getHubAddr().call();\n\n          case 4:\n            relayHubAddress = _context3.sent;\n            _context3.next = 10;\n            break;\n\n          case 7:\n            _context3.prev = 7;\n            _context3.t0 = _context3[\"catch\"](1);\n            throw new Error(\"Could not get relay hub address from recipient at \".concat(recipientAddress, \" (\").concat(_context3.t0.message, \"). Make sure it is a valid recipient contract.\"));\n\n          case 10:\n            if (!(!relayHubAddress || ethUtils.isZeroAddress(relayHubAddress))) {\n              _context3.next = 12;\n              break;\n            }\n\n            throw new Error(\"The relay hub address is set to zero in recipient at \".concat(recipientAddress, \". Make sure it is a valid recipient contract.\"));\n\n          case 12:\n            _context3.next = 14;\n            return web3.eth.getCode(relayHubAddress);\n\n          case 14:\n            code = _context3.sent;\n\n            if (!(code.length <= 2)) {\n              _context3.next = 17;\n              break;\n            }\n\n            throw new Error(\"Relay hub is not deployed at address \".concat(relayHubAddress));\n\n          case 17:\n            relayHub = createRelayHub(web3, relayHubAddress);\n            _context3.prev = 18;\n            _context3.next = 21;\n            return relayHub.methods.version().call();\n\n          case 21:\n            hubVersion = _context3.sent;\n            _context3.next = 27;\n            break;\n\n          case 24:\n            _context3.prev = 24;\n            _context3.t1 = _context3[\"catch\"](18);\n            throw new Error(\"Could not query relay hub version at \".concat(relayHubAddress, \" (\").concat(_context3.t1.message, \"). Make sure the address corresponds to a relay hub.\"));\n\n          case 27:\n            if (hubVersion.startsWith('1')) {\n              _context3.next = 29;\n              break;\n            }\n\n            throw new Error(\"Unsupported relay hub version '\".concat(hubVersion, \"'.\"));\n\n          case 29:\n            return _context3.abrupt(\"return\", relayHub);\n\n          case 30:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[1, 7], [18, 24]]);\n  }));\n  return _createRelayHubFromRecipient.apply(this, arguments);\n}\n\nfunction createRelayRecipient(web3, addr) {\n  return new web3.eth.Contract(relayRecipientAbi, addr);\n}\n\nfunction createRelayHub(web3, addr) {\n  return new web3.eth.Contract(relayHubAbi, addr);\n}\n\nfunction isRelayHubDeployedForRecipient(_x6, _x7) {\n  return _isRelayHubDeployedForRecipient.apply(this, arguments);\n}\n\nfunction _isRelayHubDeployedForRecipient() {\n  _isRelayHubDeployedForRecipient = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(web3, recipientAddr) {\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return createRelayHubFromRecipient(web3, recipientAddr);\n\n          case 3:\n            return _context4.abrupt(\"return\", true);\n\n          case 6:\n            _context4.prev = 6;\n            _context4.t0 = _context4[\"catch\"](0);\n            return _context4.abrupt(\"return\", false);\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[0, 6]]);\n  }));\n  return _isRelayHubDeployedForRecipient.apply(this, arguments);\n}\n\nfunction getRecipientFunds(_x8, _x9) {\n  return _getRecipientFunds.apply(this, arguments);\n}\n\nfunction _getRecipientFunds() {\n  _getRecipientFunds = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee5(web3, recipientAddr) {\n    var relayHub;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return createRelayHubFromRecipient(web3, recipientAddr);\n\n          case 2:\n            relayHub = _context5.sent;\n            _context5.next = 5;\n            return relayHub.methods.balanceOf(recipientAddr).call();\n\n          case 5:\n            return _context5.abrupt(\"return\", _context5.sent);\n\n          case 6:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _getRecipientFunds.apply(this, arguments);\n}\n\nmodule.exports = {\n  appendAddress: appendAddress,\n  callAsJsonRpc: callAsJsonRpc,\n  toInt: toInt,\n  preconditionCodeToDescription: preconditionCodeToDescription,\n  fixTransactionReceiptResponse: fixTransactionReceiptResponse,\n  getApprovalData: getApprovalData,\n  fixSignature: fixSignature,\n  makeApproveFunction: makeApproveFunction,\n  createRelayHubFromRecipient: createRelayHubFromRecipient,\n  isRelayHubDeployedForRecipient: isRelayHubDeployedForRecipient,\n  getRecipientFunds: getRecipientFunds\n};","map":null,"metadata":{},"sourceType":"script"}