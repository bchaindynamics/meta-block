{"ast":null,"code":"var _defineProperty = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar utils = require('./utils');\n\nvar getTransactionSignature = utils.getTransactionSignature;\nvar getTransactionSignatureWithKey = utils.getTransactionSignatureWithKey;\nvar parseHexString = utils.parseHexString;\nvar removeHexPrefix = utils.removeHexPrefix;\nvar padTo64 = utils.padTo64;\n\nvar ServerHelper = require('./ServerHelper');\n\nvar HttpWrapper = require('./HttpWrapper');\n\nvar ethUtils = require('ethereumjs-util');\n\nvar ethWallet = require('ethereumjs-wallet');\n\nvar ethJsTx = require('ethereumjs-tx');\n\nvar abi_decoder = require('abi-decoder');\n\nvar BN = require('bignumber.js');\n\nvar _require = require('../utils'),\n    appendAddress = _require.appendAddress,\n    toInt = _require.toInt,\n    preconditionCodeToDescription = _require.preconditionCodeToDescription,\n    getApprovalData = _require.getApprovalData,\n    createRelayHubFromRecipient = _require.createRelayHubFromRecipient;\n\nvar relayHubAbi = require('./IRelayHub');\n\nvar relayRecipientAbi = require('./IRelayRecipient');\n\nvar relay_lookup_limit_blocks = 6000;\nabi_decoder.addABI(relayHubAbi); // default timeout (in ms) for http requests\n\nvar DEFAULT_HTTP_TIMEOUT = 10000; //default gas price (unless client specifies one): the web3.eth.gasPrice*(100+GASPRICE_PERCENT)/100\n\nvar GASPRICE_PERCENT = 20;\n\nvar RelayClient =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  /**\n   * create a RelayClient library object, to force contracts to go through a relay.\n   * @param web3  - the web3 instance to use.\n   * @param {object} config options\n   *    txfee\n   *lookup for relay\n   *    minStake - ignore relays with stake below this (wei) value.\n   *    minDelay - ignore relays with delay lower this (sec) value\n   *\n   *    calculateRelayScore - function to give a \"score\" to a relay, based on its properties:\n   *          transactionFee, stake, unstakeDelay, relayUrl.\n   *          return null to filter-out the relay completely\n   *          default function uses just trasnactionFee (gives highest score to lowest fee)\n   *\n   *    gaspriceFactorPercent - increase (in %) over current gasPrice average. default is 10%.\n   *          Note that the resulting gasPrice must be accepted by relay (above its minGasPrice)\n   *\n   *manual settings: these can be used to override the default setting.\n   *    relayUrl, relayAddress - avoid lookup on relayHub for relays, and always use this URL/address\n   *    force_gasLimit - force gaslimit, instead of transaction paramter\n   *    force_gasPrice - force gasPrice, instread of transaction parameter.\n   */\n  function RelayClient(web3, config) {\n    _classCallCheck(this, RelayClient);\n\n    // TODO: require sign() or privKey\n    //fill in defaults:\n    this.config = Object.assign({\n      httpTimeout: DEFAULT_HTTP_TIMEOUT\n    }, config);\n    this.web3 = web3;\n    this.httpSend = new HttpWrapper({\n      timeout: this.config.httpTimeout\n    });\n    this.failedRelays = {};\n    this.serverHelper = this.config.serverHelper || new ServerHelper(this.httpSend, this.failedRelays, this.config);\n  }\n\n  _createClass(RelayClient, [{\n    key: \"sendTransaction\",\n    value: function () {\n      var _sendTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(payload) {\n        var relayOptions, tx;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                relayOptions = this.getTransactionOptions(payload);\n                _context.next = 3;\n                return this.relayTransaction(payload.params[0].data, relayOptions);\n\n              case 3:\n                tx = _context.sent;\n                return _context.abrupt(\"return\", ethUtils.bufferToHex(tx.hash(true)));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sendTransaction(_x) {\n        return _sendTransaction.apply(this, arguments);\n      }\n\n      return sendTransaction;\n    }()\n  }, {\n    key: \"getTransactionOptions\",\n    value: function getTransactionOptions(payload) {\n      var params = payload.params[0];\n      var relayClientOptions = this.config;\n      var relayOptions = {\n        from: params.from,\n        to: params.to,\n        txfee: params.txFee || params.txfee || relayClientOptions.txFee || relayClientOptions.txfee,\n        gas_limit: params.gas && toInt(params.gas),\n        gas_price: params.gasPrice && toInt(params.gasPrice),\n        approveFunction: params.approveFunction || this.config.approveFunction\n      };\n      if (relayClientOptions.verbose) console.log('RR: ', payload.id, relayOptions);\n      return relayOptions;\n    }\n    /**\n     * Decode the signed transaction returned from the Relay Server, compare it to the\n     * requested transaction and validate its signature.\n     * @returns a signed {@link ethJsTx} instance for broacasting, or null if returned\n     * transaction is not valid.\n     */\n\n  }, {\n    key: \"validateRelayResponse\",\n    value: function validateRelayResponse(returned_tx, address_relay, from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address, sig, approvalData) {\n      var tx = new ethJsTx({\n        nonce: returned_tx.nonce,\n        gasPrice: returned_tx.gasPrice,\n        gasLimit: returned_tx.gas,\n        to: returned_tx.to,\n        value: returned_tx.value,\n        data: returned_tx.input\n      });\n      var message = tx.hash(false);\n      var tx_v = Buffer.from(removeHexPrefix(returned_tx.v), \"hex\");\n      var tx_r = Buffer.from(padTo64(removeHexPrefix(returned_tx.r)), \"hex\");\n      var tx_s = Buffer.from(padTo64(removeHexPrefix(returned_tx.s)), \"hex\");\n      var signer = ethUtils.bufferToHex(ethUtils.pubToAddress(ethUtils.ecrecover(message, tx_v[0], tx_r, tx_s)));\n      var request_decoded_params = abi_decoder.decodeMethod(returned_tx.input).params;\n      var returned_tx_params_hash = utils.getTransactionHash(request_decoded_params[0].value, request_decoded_params[1].value, request_decoded_params[2].value, request_decoded_params[3].value, request_decoded_params[4].value, request_decoded_params[5].value, request_decoded_params[6].value, returned_tx.to, signer);\n      var transaction_orig_params_hash = utils.getTransactionHash(from, to, transaction_orig, transaction_fee, gas_price, gas_limit, nonce, relay_hub_address, relay_address);\n\n      if (returned_tx_params_hash === transaction_orig_params_hash && address_relay === signer) {\n        if (this.config.verbose) {\n          console.log(\"validateRelayResponse - valid transaction response\");\n        }\n\n        tx.v = tx_v;\n        tx.r = tx_r;\n        tx.s = tx_s;\n        return tx;\n      } else {\n        console.error(\"validateRelayResponse: req\", JSON.stringify(request_decoded_params));\n        console.error(\"validateRelayResponse: rsp\", {\n          returned_tx: returned_tx,\n          address_relay: address_relay,\n          from: from,\n          to: to,\n          transaction_orig: transaction_orig,\n          transaction_fee: transaction_fee,\n          gas_price: gas_price,\n          gas_limit: gas_limit,\n          nonce: nonce,\n          sig: sig,\n          approvalData: approvalData,\n          signer: signer\n        });\n      }\n    }\n    /**\n     * Performs a '/relay' HTTP request to the given url\n     * @returns a Promise that resolves to an instance of {@link ethJsTx} signed by a relay\n     */\n\n  }, {\n    key: \"sendViaRelay\",\n    value: function sendViaRelay(relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, signature, approvalData, relayUrl, relayHubAddress, relayMaxNonce) {\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        var jsonRequestData = {\n          \"encodedFunction\": encodedFunction,\n          \"signature\": parseHexString(signature.replace(/^0x/, '')),\n          \"approvalData\": parseHexString(approvalData.replace(/^0x/, '')),\n          \"from\": from,\n          \"to\": to,\n          \"gasPrice\": gasprice,\n          \"gasLimit\": gaslimit,\n          \"relayFee\": relayFee,\n          \"RecipientNonce\": parseInt(recipientNonce),\n          \"RelayMaxNonce\": parseInt(relayMaxNonce),\n          \"RelayHubAddress\": relayHubAddress\n        };\n\n        var callback =\n        /*#__PURE__*/\n        function () {\n          var _ref = _asyncToGenerator(\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _callee2(error, body) {\n            var validTransaction, receivedNonce, raw_tx, txHash;\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (!error) {\n                      _context2.next = 4;\n                      break;\n                    }\n\n                    if (error.error && error.error.indexOf(\"timeout\") != -1) {\n                      self.failedRelays[relayUrl] = {\n                        lastError: new Date().getTime(),\n                        address: relayAddress,\n                        url: relayUrl\n                      };\n                    }\n\n                    reject(error);\n                    return _context2.abrupt(\"return\");\n\n                  case 4:\n                    if (self.config.verbose) {\n                      console.log(\"sendViaRelay resp=\", body);\n                    }\n\n                    if (!(body && body.error)) {\n                      _context2.next = 8;\n                      break;\n                    }\n\n                    reject(body.error);\n                    return _context2.abrupt(\"return\");\n\n                  case 8:\n                    if (!(!body || !body.nonce)) {\n                      _context2.next = 11;\n                      break;\n                    }\n\n                    reject(\"Empty body received from server, or neither 'error' nor 'nonce' fields present.\");\n                    return _context2.abrupt(\"return\");\n\n                  case 11:\n                    try {\n                      validTransaction = self.validateRelayResponse(body, relayAddress, from, to, encodedFunction, relayFee, gasprice, gaslimit, recipientNonce, relayHubAddress, relayAddress, signature, approvalData);\n                    } catch (error) {\n                      console.error(\"validateRelayResponse \" + error);\n                    }\n\n                    if (validTransaction) {\n                      _context2.next = 15;\n                      break;\n                    }\n\n                    reject(\"Failed to validate response\");\n                    return _context2.abrupt(\"return\");\n\n                  case 15:\n                    receivedNonce = validTransaction.nonce.readUIntBE(0, validTransaction.nonce.byteLength);\n\n                    if (!(receivedNonce > relayMaxNonce)) {\n                      _context2.next = 19;\n                      break;\n                    }\n\n                    // TODO: need to validate that client retries the same request and doesn't double-spend.\n                    // Note that this transaction is totally valid from the EVM's point of view\n                    reject(\"Relay used a tx nonce higher than requested. Requested \" + relayMaxNonce + \" got \" + receivedNonce);\n                    return _context2.abrupt(\"return\");\n\n                  case 19:\n                    raw_tx = '0x' + validTransaction.serialize().toString('hex');\n                    txHash = \"0x\" + validTransaction.hash(true).toString('hex');\n                    if (self.config.verbose) console.log(\"txHash= \" + txHash);\n                    self.broadcastRawTx(raw_tx, txHash);\n                    resolve(validTransaction);\n\n                  case 24:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function callback(_x2, _x3) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n\n        if (self.config.verbose) {\n          var replacer = function replacer(key, value) {\n            if (key === \"signature\") return signature;else return value;\n          };\n\n          console.log(\"sendViaRelay to URL: \" + relayUrl + \" \" + JSON.stringify(jsonRequestData, replacer));\n        }\n\n        self.httpSend.send(relayUrl + \"/relay\", jsonRequestData, callback);\n      });\n    }\n    /**\n     * In case Relay Server does not broadcast the signed transaction to the network,\n     * client also broadcasts the same transaction. If the transaction fails with nonce\n     * error, it indicates Relay may have signed multiple transactions with same nonce,\n     * causing a DoS attack.\n     *\n     * @param {*} raw_tx - raw transaction bytes, signed by relay\n     * @param {*} tx_hash - this transaction's ID\n     */\n\n  }, {\n    key: \"broadcastRawTx\",\n    value: function broadcastRawTx(raw_tx, tx_hash) {\n      var self = this;\n      self.web3.eth.sendSignedTransaction(raw_tx, function (error, result) {\n        //TODO: at this point both client and relay has sent the transaction to the blockchain.\n        // client should send the transaction to a SECONDARY relay, so it can wait and attempt\n        // to penalize original relay for cheating: returning one transaction to the client, and\n        // broadcasting another with the same nonce.\n        // see the EIP for description of the attack\n        //don't display error for the known-good cases\n        if (!(\"\" + error).match(/the tx doesn't have the correct nonce|known transaction/)) {\n          if (self.config.verbose) {\n            // TODO: Should we actually bubble up an error?\n            console.log(\"broadcastTx: \", error || result);\n          }\n        }\n\n        if (error) {//note that nonce-related errors at this point are VALID reponses: it means that\n          // the client confirms the relay didn't attempt to delay broadcasting the transaction.\n          // the only point is that different node versions return different error strings:\n          // ganache:  \"the tx doesn't have the correct nonce\"\n          // ropsten: \"known transaction\"\n        } else {\n          if (result == tx_hash) {//transaction already on chain\n          }\n        }\n      });\n    }\n    /**\n     * check the balance of the given target contract.\n     * the method will fail if the target is not a RelayRecipient.\n     * (not strictly a client operation, but without a balance, the target contract can't accept calls)\n     */\n\n  }, {\n    key: \"balanceOf\",\n    value: function () {\n      var _balanceOf = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(target) {\n        var relayHub;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return createRelayHubFromRecipient(this.web3, target);\n\n              case 2:\n                relayHub = _context3.sent;\n                return _context3.abrupt(\"return\", relayHub.methods.balanceOf(target).call());\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function balanceOf(_x4) {\n        return _balanceOf.apply(this, arguments);\n      }\n\n      return balanceOf;\n    }()\n    /**\n     * Options include standard transaction params: from,to, gasprice, gaslimit\n     * can also override default relayUrl, relayFee\n     * return value is the same as from sendTransaction\n     */\n\n  }, {\n    key: \"relayTransaction\",\n    value: function () {\n      var _relayTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(encodedFunctionCall, options) {\n        var self, relayHub, nonce, pct, network_gas_price, gasPrice, gasLimit, blockNow, blockFrom, pinger, errors, activeRelay, subErrors, error, relayAddress, relayUrl, txfee, hash, signature, approvalData, rec, allowed_relay_nonce_gap, relayMaxNonce, validTransaction, errMsg;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                self = this;\n                _context4.next = 3;\n                return createRelayHubFromRecipient(this.web3, options.to);\n\n              case 3:\n                relayHub = _context4.sent;\n                _context4.t0 = parseInt;\n                _context4.next = 7;\n                return relayHub.methods.getNonce(options.from).call();\n\n              case 7:\n                _context4.t1 = _context4.sent;\n                nonce = (0, _context4.t0)(_context4.t1);\n                this.serverHelper.setHub(relayHub); //gas-price multiplicator: either default (10%) or configuration factor\n\n                pct = this.config.gasPriceFactorPercent || this.config.gaspriceFactorPercent || GASPRICE_PERCENT;\n                _context4.next = 13;\n                return this.web3.eth.getGasPrice();\n\n              case 13:\n                network_gas_price = _context4.sent;\n\n                // Sometimes, xDai netwiork returns '0'\n                if (!network_gas_price || network_gas_price == 0) {\n                  network_gas_price = 1e9;\n                }\n\n                gasPrice = this.config.fixedGasPrice || //forced gasprice\n                this.config.force_gasPrice || options.gas_price || //user-supplied gas price\n                Math.round(network_gas_price * (pct + 100) / 100); //TODO: should add gas estimation for encodedFunctionCall (tricky, since its not a real transaction)\n\n                gasLimit = this.config.fixedGasLimit || this.config.force_gasLimit || options.gas_limit; // If we don't have a gas limit, then estimate it, since we need a concrete value for checking the recipient balance\n\n                _context4.prev = 17;\n\n                if (gasLimit) {\n                  _context4.next = 22;\n                  break;\n                }\n\n                _context4.next = 21;\n                return this.estimateGas(_objectSpread({}, options, {\n                  gasPrice: gasPrice,\n                  data: encodedFunctionCall\n                }), relayHub.options.address);\n\n              case 21:\n                gasLimit = _context4.sent;\n\n              case 22:\n                _context4.next = 27;\n                break;\n\n              case 24:\n                _context4.prev = 24;\n                _context4.t2 = _context4[\"catch\"](17);\n                throw new Error(\"Error estimating gas usage for transaction (\".concat(_context4.t2.message, \"). Make sure the transaction is valid, or set a fixed gas value.\"));\n\n              case 27:\n                _context4.next = 29;\n                return this.validateRecipientBalance(relayHub, options.to, gasLimit, gasPrice, 0);\n\n              case 29:\n                _context4.next = 31;\n                return this.web3.eth.getBlockNumber();\n\n              case 31:\n                blockNow = _context4.sent;\n                blockFrom = Math.max(1, blockNow - relay_lookup_limit_blocks);\n                _context4.next = 35;\n                return this.serverHelper.newActiveRelayPinger(blockFrom, gasPrice);\n\n              case 35:\n                pinger = _context4.sent;\n                errors = [];\n\n              case 37:\n                _context4.next = 39;\n                return pinger.nextRelay();\n\n              case 39:\n                activeRelay = _context4.sent;\n\n                if (activeRelay) {\n                  _context4.next = 45;\n                  break;\n                }\n\n                subErrors = errors.concat(pinger.errors);\n                error = new Error(\"No relayer responded or accepted the transaction out of the \".concat(pinger.pingedRelays, \" queried:\\n\").concat(subErrors.map(function (err) {\n                  return \" \".concat(err);\n                }).join('\\n')));\n                error.errors = subErrors;\n                throw error;\n\n              case 45:\n                relayAddress = activeRelay.RelayServerAddress;\n                relayUrl = activeRelay.relayUrl;\n                txfee = parseInt(options.txfee || activeRelay.transactionFee);\n                hash = void 0, signature = void 0;\n                _context4.prev = 49;\n                hash = utils.getTransactionHash(options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, relayHub._address, relayAddress);\n\n                if (!(typeof self.ephemeralKeypair === \"object\" && self.ephemeralKeypair !== null)) {\n                  _context4.next = 57;\n                  break;\n                }\n\n                _context4.next = 54;\n                return getTransactionSignatureWithKey(self.ephemeralKeypair.privateKey, hash);\n\n              case 54:\n                signature = _context4.sent;\n                _context4.next = 60;\n                break;\n\n              case 57:\n                _context4.next = 59;\n                return getTransactionSignature(this.web3, options.from, hash);\n\n              case 59:\n                signature = _context4.sent;\n\n              case 60:\n                _context4.next = 65;\n                break;\n\n              case 62:\n                _context4.prev = 62;\n                _context4.t3 = _context4[\"catch\"](49);\n                throw new Error(\"Error generating signature for transaction: \".concat(_context4.t3.message || _context4.t3));\n\n              case 65:\n                _context4.next = 67;\n                return getApprovalData(options.approveFunction, {\n                  from: options.from,\n                  to: options.to,\n                  encodedFunctionCall: encodedFunctionCall,\n                  txFee: txfee,\n                  gasPrice: gasPrice,\n                  gas: gasLimit,\n                  nonce: nonce,\n                  relayHubAddress: relayHub._address,\n                  relayerAddress: relayAddress\n                });\n\n              case 67:\n                approvalData = _context4.sent;\n\n                if (self.config.verbose) {\n                  console.log(\"relayTransaction hash: \", hash, \"from: \", options.from, \"sig: \", signature);\n                  rec = utils.getEcRecoverMeta(hash, signature);\n\n                  if (rec.toLowerCase() === options.from.toLowerCase()) {\n                    console.log(\"relayTransaction recovered:\", rec, \"signature is correct\");\n                  } else {\n                    console.error(\"relayTransaction recovered:\", rec, \"signature error\");\n                  }\n                } // max nonce is not signed, as contracts cannot access addresses' nonces.\n\n\n                allowed_relay_nonce_gap = this.config.allowed_relay_nonce_gap || this.config.allowedRelayNonceGap;\n\n                if (typeof allowed_relay_nonce_gap === \"undefined\") {\n                  allowed_relay_nonce_gap = 3;\n                }\n\n                _context4.next = 73;\n                return this.web3.eth.getTransactionCount(relayAddress);\n\n              case 73:\n                _context4.t4 = _context4.sent;\n                _context4.t5 = allowed_relay_nonce_gap;\n                relayMaxNonce = _context4.t4 + _context4.t5;\n                _context4.prev = 76;\n                _context4.next = 79;\n                return self.sendViaRelay(relayAddress, options.from, options.to, encodedFunctionCall, txfee, gasPrice, gasLimit, nonce, signature, approvalData, relayUrl, relayHub._address, relayMaxNonce);\n\n              case 79:\n                validTransaction = _context4.sent;\n                return _context4.abrupt(\"return\", validTransaction);\n\n              case 83:\n                _context4.prev = 83;\n                _context4.t6 = _context4[\"catch\"](76);\n                errMsg = (_context4.t6.message || _context4.t6).toString().replace(/canRelay\\(\\) view function returned error code=(\\d+)\\..+/, function (_match, code) {\n                  return \"canRelay check failed with \".concat(preconditionCodeToDescription(code));\n                });\n                errors.push(\"Error sending transaction via relayer \".concat(relayAddress, \": \").concat(errMsg));\n\n                if (self.config.verbose) {\n                  console.log(\"relayTransaction: req:\", {\n                    from: options.from,\n                    to: options.to,\n                    encodedFunctionCall: encodedFunctionCall,\n                    txfee: txfee,\n                    gasPrice: gasPrice,\n                    gasLimit: gasLimit,\n                    nonce: nonce,\n                    relayhub: relayHub._address,\n                    relayAddress: relayAddress\n                  });\n                  console.log(\"relayTransaction:\", (\"\" + _context4.t6).replace(/ (\\w+:)/g, \"\\n$1 \"));\n                }\n\n              case 88:\n                _context4.next = 37;\n                break;\n\n              case 90:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[17, 24], [49, 62], [76, 83]]);\n      }));\n\n      function relayTransaction(_x5, _x6) {\n        return _relayTransaction.apply(this, arguments);\n      }\n\n      return relayTransaction;\n    }()\n  }, {\n    key: \"postAuditTransaction\",\n    value: function postAuditTransaction(signedTx, relayUrl) {\n      var self = this;\n      return new Promise(function (resolve, reject) {\n        var callback = function callback(error, response) {\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          resolve(response);\n        };\n\n        self.httpSend.send(relayUrl + \"/audit\", {\n          signedTx: signedTx\n        }, callback);\n      });\n    }\n    /**\n     * Send a transaction signed by a relay to other relays for audit.\n     * This is done in order to prevent nonce reuse by a misbehaving relay.\n     *\n     * @param {*} transaction\n     * @param {*} auditingRelays - array of URLs of known relays to report this transaction to\n     */\n\n  }, {\n    key: \"auditTransaction\",\n    value: function () {\n      var _auditTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(transaction, auditingRelays) {\n        var relay;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.t0 = _regeneratorRuntime.keys(auditingRelays);\n\n              case 1:\n                if ((_context5.t1 = _context5.t0()).done) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                relay = _context5.t1.value;\n                _context5.next = 5;\n                return this.postAuditTransaction(transaction, auditingRelays[relay]);\n\n              case 5:\n                _context5.next = 1;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function auditTransaction(_x7, _x8) {\n        return _auditTransaction.apply(this, arguments);\n      }\n\n      return auditTransaction;\n    }()\n  }, {\n    key: \"useKeypairForSigning\",\n    value: function useKeypairForSigning(ephemeralKeypair) {\n      if (ephemeralKeypair && typeof ephemeralKeypair.privateKey === 'string') {\n        ephemeralKeypair.privateKey = Buffer.from(removeHexPrefix(ephemeralKeypair.privateKey), \"hex\");\n      }\n\n      this.ephemeralKeypair = ephemeralKeypair;\n    }\n  }, {\n    key: \"validateRecipientBalance\",\n    value: function () {\n      var _validateRecipientBalance = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(relayHub, recipient, gasLimit, gasPrice, relayFee) {\n        var balance, maxCharge;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return relayHub.methods.balanceOf(recipient).call();\n\n              case 2:\n                balance = _context6.sent;\n\n                if (!BN(balance).isZero()) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Recipient \".concat(recipient, \" has no funds for paying for relayed calls on the relay hub.\"));\n\n              case 5:\n                _context6.next = 7;\n                return relayHub.methods.maxPossibleCharge(gasLimit, gasPrice, relayFee).call();\n\n              case 7:\n                maxCharge = _context6.sent;\n\n                if (!BN(maxCharge).isGreaterThan(BN(balance))) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                throw new Error(\"Recipient \".concat(recipient, \" has not enough funds for paying for this relayed call (has \").concat(balance, \", requires \").concat(maxCharge, \").\"));\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function validateRecipientBalance(_x9, _x10, _x11, _x12, _x13) {\n        return _validateRecipientBalance.apply(this, arguments);\n      }\n\n      return validateRecipientBalance;\n    }()\n  }, {\n    key: \"estimateGas\",\n    value: function () {\n      var _estimateGas = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(txParams, hubAddress) {\n        var hub, txParamsFromHub;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (hubAddress) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                _context7.next = 3;\n                return createRelayHubFromRecipient(this.web3, txParams.to);\n\n              case 3:\n                hub = _context7.sent;\n                hubAddress = hub.options.address;\n\n              case 5:\n                txParamsFromHub = _objectSpread({}, txParams, {\n                  from: hubAddress,\n                  data: appendAddress(txParams.data, txParams.from)\n                });\n                return _context7.abrupt(\"return\", this.web3.eth.estimateGas(txParamsFromHub));\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function estimateGas(_x14, _x15) {\n        return _estimateGas.apply(this, arguments);\n      }\n\n      return estimateGas;\n    }()\n  }], [{\n    key: \"newEphemeralKeypair\",\n    value: function newEphemeralKeypair() {\n      var a = ethWallet.generate();\n      return {\n        privateKey: a.privKey,\n        address: \"0x\" + a.getAddress().toString('hex')\n      };\n    }\n  }]);\n\n  return RelayClient;\n}();\n\nmodule.exports = RelayClient;","map":null,"metadata":{},"sourceType":"script"}