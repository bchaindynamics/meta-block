{"ast":null,"code":"var _regeneratorRuntime = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('ethereumjs-wallet'),\n    fromPrivateKey = _require.fromPrivateKey;\n\nvar _require2 = require('./utils'),\n    callAsJsonRpc = _require2.callAsJsonRpc;\n\nvar ethUtil = require('ethereumjs-util');\n\nvar sigUtil = require('eth-sig-util');\n\nvar EthereumTx = require('ethereumjs-tx');\n\nvar PrivateKeyProvider =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function PrivateKeyProvider(base, privateKey) {\n    _classCallCheck(this, PrivateKeyProvider);\n\n    // Build ethereumjs-wallet from privateKey\n    this.wallet = this._getWalletFromPrivateKey(privateKey);\n    this.address = ethUtil.toChecksumAddress(ethUtil.bufferToHex(this.wallet.getAddress())); // Patch base provider if needed\n\n    this.baseSend = (base.sendAsync || base.send).bind(base);\n    this.sendAsync = this.send.bind(this);\n    this.baseProvider = base;\n    this.messageId = 0;\n    this.isPrivateKeyProvider = true;\n  }\n\n  _createClass(PrivateKeyProvider, [{\n    key: \"send\",\n    value: function send(payload, callback) {\n      var from, data, txParams, signature;\n      var id = payload.id;\n\n      switch (payload.method) {\n        case 'eth_accounts':\n          callAsJsonRpc(this.ethAccounts.bind(this), [], id, callback);\n          break;\n\n        case 'eth_sign':\n          var _payload$params = _slicedToArray(payload.params, 2);\n\n          from = _payload$params[0];\n          data = _payload$params[1];\n          callAsJsonRpc(this.ethSign.bind(this), [from, data], id, callback);\n          break;\n\n        case 'eth_signTransaction':\n          var _payload$params2 = _slicedToArray(payload.params, 1);\n\n          txParams = _payload$params2[0];\n          callAsJsonRpc(this.ethSignTransaction.bind(this), [txParams], id, callback, function (signedTx) {\n            return {\n              tx: txParams,\n              raw: signedTx\n            };\n          });\n          break;\n\n        case 'eth_signTypedData':\n          var _payload$params3 = _slicedToArray(payload.params, 2);\n\n          from = _payload$params3[0];\n          data = _payload$params3[1];\n          callAsJsonRpc(this.ethSignTypedData.bind(this), [from, data], id, callback);\n          break;\n\n        case 'eth_sendTransaction':\n          // TODO: Implement this method before releasing this as a standalone provider\n          return this.baseSend(payload, callback);\n\n        case 'personal_sign':\n          var _payload$params4 = _slicedToArray(payload.params, 2);\n\n          data = _payload$params4[0];\n          from = _payload$params4[1];\n          callAsJsonRpc(this.personalSign.bind(this), [from, data], id, callback);\n          break;\n\n        case 'personal_ecRecover':\n          var _payload$params5 = _slicedToArray(payload.params, 2);\n\n          data = _payload$params5[0];\n          signature = _payload$params5[1];\n          callAsJsonRpc(this.personalEcRecover.bind(this), [data, signature], id, callback);\n          break;\n\n        default:\n          return this.baseSend(payload, callback);\n      }\n    }\n  }, {\n    key: \"ethAccounts\",\n    value: function () {\n      var _ethAccounts = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", [this.address]);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function ethAccounts() {\n        return _ethAccounts.apply(this, arguments);\n      }\n\n      return ethAccounts;\n    }() // Adapted from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\n\n  }, {\n    key: \"ethSign\",\n    value: function () {\n      var _ethSign = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(signer, data) {\n        var dataBuff, msgHash, sig;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._validateSigner(signer);\n\n                if (data) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Data to sign cannot be null\");\n\n              case 3:\n                dataBuff = ethUtil.toBuffer(data);\n                msgHash = ethUtil.hashPersonalMessage(dataBuff);\n                sig = ethUtil.ecsign(msgHash, this.wallet.getPrivateKey());\n                return _context2.abrupt(\"return\", ethUtil.bufferToHex(concatSig(sig.v, sig.r, sig.s)));\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function ethSign(_x, _x2) {\n        return _ethSign.apply(this, arguments);\n      }\n\n      return ethSign;\n    }()\n  }, {\n    key: \"ethSignTypedData\",\n    value: function () {\n      var _ethSignTypedData = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(signer, data) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._validateSigner(signer);\n\n                if (data) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Data to sign cannot be null\");\n\n              case 3:\n                return _context3.abrupt(\"return\", sigUtil.signTypedData(this.wallet.getPrivateKey(), {\n                  data: data\n                }));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function ethSignTypedData(_x3, _x4) {\n        return _ethSignTypedData.apply(this, arguments);\n      }\n\n      return ethSignTypedData;\n    }()\n  }, {\n    key: \"personalSign\",\n    value: function () {\n      var _personalSign = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(signer, data) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._validateSigner(signer);\n\n                if (data) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Data to sign cannot be null\");\n\n              case 3:\n                return _context4.abrupt(\"return\", sigUtil.personalSign(this.wallet.getPrivateKey(), {\n                  data: data\n                }));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function personalSign(_x5, _x6) {\n        return _personalSign.apply(this, arguments);\n      }\n\n      return personalSign;\n    }()\n  }, {\n    key: \"personalEcRecover\",\n    value: function () {\n      var _personalEcRecover = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(data, sig) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (sig) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error(\"Signature for ecRecover cannot be null\");\n\n              case 2:\n                if (data) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                throw new Error(\"Data for ecRecover cannot be null\");\n\n              case 4:\n                return _context5.abrupt(\"return\", sigUtil.recoverPersonalSignature({\n                  data: data,\n                  sig: sig\n                }));\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function personalEcRecover(_x7, _x8) {\n        return _personalEcRecover.apply(this, arguments);\n      }\n\n      return personalEcRecover;\n    }() // Adapted from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\n\n  }, {\n    key: \"ethSignTransaction\",\n    value: function () {\n      var _ethSignTransaction = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(txData) {\n        var privateKey, tx;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._validateSigner(txData.from); // TODO: Fill in gas, gasPrice, and nonce if missing instead of failing\n\n\n                if (!(!txData.gas && !txData.gasLimit)) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Gas limit for transaction is required (\".concat(txData, \")\"));\n\n              case 3:\n                if (txData.gasPrice) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Gas price for transaction is required (\".concat(txData, \")\"));\n\n              case 5:\n                if (txData.nonce) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Nonce for transaction is required (\".concat(txData, \")\"));\n\n              case 7:\n                // Format gas, value, and data for ethereum-tx\n                if (txData.gas !== undefined) txData.gasLimit = txData.gas;\n                txData.value = txData.value || '0x00';\n                txData.data = ethUtil.addHexPrefix(txData.data); // Build ethereum-tx object and sign it\n\n                privateKey = this.wallet.getPrivateKey();\n                tx = new EthereumTx(txData);\n                tx.sign(privateKey);\n                return _context6.abrupt(\"return\", ethUtil.bufferToHex(tx.serialize()));\n\n              case 14:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function ethSignTransaction(_x9) {\n        return _ethSignTransaction.apply(this, arguments);\n      }\n\n      return ethSignTransaction;\n    }()\n  }, {\n    key: \"_validateSigner\",\n    value: function _validateSigner(signer) {\n      if (!signer) {\n        throw new Error(\"Signer address is required\");\n      }\n\n      if (signer.toLowerCase() !== this.address.toLowerCase()) {\n        throw new Error(\"Unknown signer \".concat(signer, \" (current signer is \").concat(this.address, \")\"));\n      }\n    }\n  }, {\n    key: \"_getWalletFromPrivateKey\",\n    value: function _getWalletFromPrivateKey(privateKey) {\n      if (!privateKey) throw new Error(\"Private key must be set\"); // This is an ethereumjs-wallet already\n\n      if (privateKey.getPrivateKey && privateKey.getAddress) return privateKey; // This is an object that contains the private key\n\n      if (privateKey.privateKey) privateKey = privateKey.privateKey; // Transform the private key into a buffer\n\n      var keyBuffer = typeof privateKey === 'string' ? new Buffer(privateKey.replace(/^0x/, ''), \"hex\") : privateKey; // Build the wallet from the key\n\n      return fromPrivateKey(keyBuffer);\n    }\n  }]);\n\n  return PrivateKeyProvider;\n}(); // Copied from https://github.com/MetaMask/web3-provider-engine/blob/master/subproviders/hooked-wallet-ethtx.js\n\n\nfunction concatSig(v, r, s) {\n  r = ethUtil.fromSigned(r);\n  s = ethUtil.fromSigned(s);\n  v = ethUtil.bufferToInt(v);\n  r = ethUtil.toUnsigned(r).toString('hex').padStart(64, 0);\n  s = ethUtil.toUnsigned(s).toString('hex').padStart(64, 0);\n  v = ethUtil.stripHexPrefix(ethUtil.intToHex(v));\n  return ethUtil.addHexPrefix(r.concat(s, v).toString(\"hex\"));\n}\n\nmodule.exports = PrivateKeyProvider;","map":null,"metadata":{},"sourceType":"script"}