{"ast":null,"code":"var _classCallCheck = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/pranshu_ubuntu/Documents/starter-kit-gsn/client/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Web3 = require('web3');\n\nvar RelayClient = require('./tabookey-gasless/RelayClient');\n\nvar PrivateKeyProvider = require('./PrivateKeyProvider');\n\nvar _require = require('./utils'),\n    callAsJsonRpc = _require.callAsJsonRpc,\n    fixTransactionReceiptResponse = _require.fixTransactionReceiptResponse;\n\nvar GSNProvider =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function GSNProvider(base) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, GSNProvider);\n\n    var web3 = new Web3(base);\n\n    this._delegateToProvider(web3.currentProvider);\n\n    this._wrapWithPrivateKey(web3, options);\n\n    base = web3.currentProvider;\n    this.baseProvider = base;\n    this.baseSend = (base.sendAsync || base.send).bind(base);\n    this.sendAsync = this.send.bind(this);\n    this.relayClient = new RelayClient(web3, options);\n    this.useGSN = options && typeof options.useGSN !== \"undefined\" ? options.useGSN : true;\n    this.isGSNProvider = true;\n    this.options = options;\n    this.relayedTxs = new Set();\n  }\n\n  _createClass(GSNProvider, [{\n    key: \"send\",\n    value: function send(payload, callback) {\n      switch (payload.method) {\n        case 'eth_sendTransaction':\n          if (this._handleSendTransaction(payload, callback)) return;\n          break;\n\n        case 'eth_estimateGas':\n          if (this._handleEstimateGas(payload, callback)) return;\n          break;\n\n        case 'eth_getTransactionReceipt':\n          if (this._handleGetTransactionReceipt(payload, callback)) return;\n          break;\n      } // Default by sending to base provider\n\n\n      return this.baseSend(payload, callback);\n    }\n  }, {\n    key: \"_handleGetTransactionReceipt\",\n    value: function _handleGetTransactionReceipt(payload, callback) {\n      var _this = this;\n\n      // Check for GSN usage\n      var txHash = payload.params[0];\n      if (!this._withGSN(payload) && !this.relayedTxs.has(txHash)) return false; // Set error status if tx was rejected\n\n      this.baseSend(payload, function (err, receipt) {\n        if (err) callback(err, null);else callback(null, fixTransactionReceiptResponse(receipt, _this.options.verbose));\n      });\n      return true;\n    }\n  }, {\n    key: \"_handleSendTransaction\",\n    value: function _handleSendTransaction(payload, callback) {\n      var _this2 = this;\n\n      // Check for GSN usage\n      var txParams = payload.params[0];\n      if (!this._withGSN(payload, txParams)) return false; // Use sign key address if set\n\n      if (!txParams.from && this.base.address) txParams.from = this.base.address; // TODO: move validations to the relay client\n\n      if (!txParams.to) {\n        return callback(new Error(\"Cannot deploy a new contract via the GSN\"), null);\n      }\n\n      if (txParams.value) {\n        var strValue = txParams.value.toString();\n\n        if (strValue !== '0' && strValue !== '0x0') {\n          return callback(new Error(\"Cannot send funds via the GSN\"), null);\n        }\n      } // Delegate to relay client\n\n\n      callAsJsonRpc(this.relayClient.sendTransaction.bind(this.relayClient), [payload], payload.id, callback, function (txHash) {\n        _this2.relayedTxs.add(txHash);\n\n        return {\n          result: txHash\n        };\n      });\n      return true;\n    }\n  }, {\n    key: \"_handleEstimateGas\",\n    value: function _handleEstimateGas(payload, callback) {\n      var txParams = payload.params[0];\n      if (!this._withGSN(payload, txParams)) return false;\n      callAsJsonRpc(this.relayClient.estimateGas.bind(this.relayClient), [txParams], payload.id, callback);\n      return true;\n    }\n  }, {\n    key: \"_withGSN\",\n    value: function _withGSN(payload, options) {\n      if (options) {\n        var useGSN = options.useGSN;\n\n        if (typeof useGSN !== 'undefined') {\n          return useGSN;\n        }\n      }\n\n      return typeof this.useGSN === 'function' ? this.useGSN(payload) : this.useGSN;\n    }\n  }, {\n    key: \"_delegateToProvider\",\n    value: function _delegateToProvider(provider) {\n      var _this3 = this;\n\n      var delegate = function delegate(fn) {\n        if (provider[fn]) _this3[fn] = provider[fn].bind(provider);\n      }; // If the subprovider is a ws or ipc provider, then register all its methods on this provider\n      // and delegate calls to the subprovider. This allows subscriptions to work.\n\n\n      delegate('on');\n      delegate('removeListener');\n      delegate('removeAllListeners');\n      delegate('reset');\n      delegate('disconnect');\n      delegate('addDefaultEvents');\n      delegate('once');\n      delegate('reconnect');\n    }\n  }, {\n    key: \"_wrapWithPrivateKey\",\n    value: function _wrapWithPrivateKey(web3, options) {\n      if (options.signKey) {\n        var provider = new PrivateKeyProvider(web3.currentProvider, options.signKey);\n        web3.setProvider(provider);\n      }\n    }\n  }]);\n\n  return GSNProvider;\n}();\n\nmodule.exports = GSNProvider;","map":null,"metadata":{},"sourceType":"script"}